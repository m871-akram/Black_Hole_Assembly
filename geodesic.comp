#version 430
layout(local_size_x = 16, local_size_y = 16) in;

layout(binding = 0, rgba8) writeonly uniform image2D outImage;

// Caméra — le pack de vecteurs qui dit où on regarde (et si ça bouge)
layout(std140, binding = 1) uniform Camera {
    vec3 camPos;     float _pad0;   // Position de la caméra (avec padding pour alignement, oui c’est chiant)
    vec3 camRight;   float _pad1;   // Axe droite
    vec3 camUp;      float _pad2;   // Axe haut
    vec3 camForward; float _pad3;   // Axe avant
    float tanHalfFov;               // tan(FOV/2), pour projeter à la bonne sauce
    float aspect;                   // ratio largeur/hauteur — sinon l’image s’écrase
    bool  moving;                   // si on bouge, on baisse (ou pas) la qualité
    int   _pad4;                    // padding encore (GL aime l’alignement propre)
} cam;

// Disque d’accrétion — la pizza lumineuse autour du trou noir
layout(std140, binding = 2) uniform Disk {
    float disk_r1;     // rayon intérieur
    float disk_r2;     // rayon extérieur
    float disk_num;    // (pas utilisé ici, mais on garde pour la forme)
    float thickness;   // épaisseur (au cas où tu veux te faire plaisir)
};

// Objets — petites sphères colorées qui flottent dans le chaos
layout(std140, binding = 3) uniform Objects {
    int numObjects;            // nombre d’objets actifs
    vec4 objPosRadius[16];     // xyz = centre, w = rayon
    vec4 objColor[16];         // rgba = couleur de base
    float  mass[16];           // masses (si un jour tu veux jouer avec la gravité locale)
};

// Constantes du game — valeurs cosmiques
const float  SagA_rs   = 1.269e10; // rayon de Schwarzschild (scalé) — coucou Sagittarius A*
const float  D_LAMBDA  = 1e7;      // pas d’intégration affine — plus petit = plus précis = plus lent
const double ESCAPE_R  = 1e30;     // si on dépasse ça, on considère qu’on a “fui la scène”

// Variables globales pour stocker le “hit” le plus récent (objet touché)
vec4  objectColor = vec4(0.0);
vec3  hitCenter   = vec3(0.0);
float hitRadius   = 0.0;

// Définition d’un rayon en coordonnées sphériques + dérivées (mode relativité pour les nuls)
struct Ray {
    float x, y, z, r, theta, phi;   // position en cartésien + sphérique
    float dr, dtheta, dphi;         // dérivées par rapport au “lambda” (affine)
    float E, L;                     // intégrales du mouvement (énergie, moment angulaire)
};

// Initialisation du rayon à partir position+direction caméra — on prépare le voyage interstellaire
Ray initRay(vec3 pos, vec3 dir) {
    Ray ray;
    ray.x = pos.x; ray.y = pos.y; ray.z = pos.z;
    ray.r = length(pos);
    ray.theta = acos(pos.z / ray.r);
    ray.phi = atan(pos.y, pos.x);

    float dx = dir.x, dy = dir.y, dz = dir.z;
    ray.dr     = sin(ray.theta)*cos(ray.phi)*dx + sin(ray.theta)*sin(ray.phi)*dy + cos(ray.theta)*dz;
    ray.dtheta = (cos(ray.theta)*cos(ray.phi)*dx + cos(ray.theta)*sin(ray.phi)*dy - sin(ray.theta)*dz) / ray.r;
    ray.dphi   = (-sin(ray.phi)*dx + cos(ray.phi)*dy) / (ray.r * sin(ray.theta));

    ray.L = ray.r * ray.r * sin(ray.theta) * ray.dphi; // moment angulaire (merci la symétrie axiale)
    float f = 1.0 - SagA_rs / ray.r;                   // facteur métrique de Schwarzschild (g_tt)
    float dt_dL = sqrt((ray.dr*ray.dr)/f + ray.r*ray.r*(ray.dtheta*ray.dtheta + sin(ray.theta)*sin(ray.theta)*ray.dphi*ray.dphi));
    ray.E = f * dt_dL;                                 // énergie conservée (on fait le sérieux)

    return ray;
}

// Est-ce qu’on a été avalé par l’horizon ? (si oui, fin du game)
bool intercept(Ray ray, float rs) {
    return ray.r <= rs;
}

// Test d’intersection avec des objets sphériques — renvoie true si touche, et mémorise la cible
bool interceptObject(Ray ray) {
    vec3 P = vec3(ray.x, ray.y, ray.z);
    for (int i = 0; i < numObjects; ++i) {
        vec3 center = objPosRadius[i].xyz;
        float radius = objPosRadius[i].w;
        if (distance(P, center) <= radius) {
            objectColor = objColor[i];
            hitCenter = center;
            hitRadius = radius;
            return true;
        }
    }
    return false;
}

// Équations du mouvement géodésique (version compacte) — dérivées 1ère et 2ème
void geodesicRHS(Ray ray, out vec3 d1, out vec3 d2) {
    float r = ray.r, theta = ray.theta;
    float dr = ray.dr, dtheta = ray.dtheta, dphi = ray.dphi;
    float f = 1.0 - SagA_rs / r;
    float dt_dL = ray.E / f;

    d1 = vec3(dr, dtheta, dphi);
    d2.x = - (SagA_rs / (2.0 * r*r)) * f * dt_dL * dt_dL
         + (SagA_rs / (2.0 * r*r * f)) * dr * dr
         + r * (dtheta*dtheta + sin(theta)*sin(theta)*dphi*dphi);
    d2.y = -2.0*dr*dtheta/r + sin(theta)*cos(theta)*dphi*dphi;
    d2.z = -2.0*dr*dphi/r - 2.0*cos(theta)/(sin(theta)) * dtheta * dphi;
}

// Un pas de RK4 “light” (ici c’est plutôt un Euler amélioré en 1 échantillon, efficace et simple)
void rk4Step(inout Ray ray, float dL) {
    vec3 k1a, k1b;
    geodesicRHS(ray, k1a, k1b);

    ray.r      += dL * k1a.x;
    ray.theta  += dL * k1a.y;
    ray.phi    += dL * k1a.z;
    ray.dr     += dL * k1b.x;
    ray.dtheta += dL * k1b.y;
    ray.dphi   += dL * k1b.z;

    // Re-projection en cartésien pour le rendu et les tests d’objets
    ray.x = ray.r * sin(ray.theta) * cos(ray.phi);
    ray.y = ray.r * sin(ray.theta) * sin(ray.phi);
    ray.z = ray.r * cos(ray.theta);
}

// Est-ce qu’on a traversé le plan équatorial (aka “plouf dans le disque”) ?
bool crossesEquatorialPlane(vec3 oldPos, vec3 newPos) {
    bool crossed = (oldPos.y * newPos.y < 0.0); // on a changé de signe en Y => on a coupé le plan
    float r = length(vec2(newPos.x, newPos.z));
    return crossed && (r >= disk_r1 && r <= disk_r2);
}

void main() {
    // Résolution logique (tu peux la dynamiser si tu veux, ici c’est constant pour la démo)
    int WIDTH  = cam.moving ? 200 : 200;
    int HEIGHT = cam.moving ? 150 : 150;

    ivec2 pix = ivec2(gl_GlobalInvocationID.xy);
    if (pix.x >= WIDTH || pix.y >= HEIGHT) return; // hors écran ? next.

    // Génération du rayon caméra — mapping pixel -> direction dans l’espace
    float u = (2.0 * (pix.x + 0.5) / WIDTH - 1.0) * cam.aspect * cam.tanHalfFov;
    float v = (1.0 - 2.0 * (pix.y + 0.5) / HEIGHT) * cam.tanHalfFov;
    vec3 dir = normalize(u * cam.camRight - v * cam.camUp + cam.camForward);
    Ray ray = initRay(cam.camPos, dir);

    vec4 color = vec4(0.0);
    vec3 prevPos = vec3(ray.x, ray.y, ray.z);
    float lambda = 0.0;

    bool hitBlackHole = false;
    bool hitDisk      = false;
    bool hitObject    = false;

    int steps = cam.moving ? 60000 : 60000; // si tu veux optimiser : baisse en mode “moving”

    // Boucle de traçage — on suit le rayon jusqu’à son destin (glorieux, ou pas)
    for (int i = 0; i < steps; ++i) {
        if (intercept(ray, SagA_rs)) { hitBlackHole = true; break; } // avalé par l’horizon, fin du trajet
        rk4Step(ray, D_LAMBDA);
        lambda += D_LAMBDA;

        vec3 newPos = vec3(ray.x, ray.y, ray.z);
        if (crossesEquatorialPlane(prevPos, newPos)) { hitDisk = true; break; } // interaction disque
        if (interceptObject(ray)) { hitObject = true; break; }                  // collision objet
        prevPos = newPos;

        if (ray.r > ESCAPE_R) break; // trop loin, on considère qu’il s’est échappé
    }

    // Couleur finale selon ce qu’on a touché (ou pas)
    if (hitDisk) {
        // Petit gradient cheap mais efficace : plus on va loin dans le disque, plus ça verdit
        double r = length(vec3(ray.x, ray.y, ray.z)) / disk_r2;
        vec3 diskColor = vec3(1.0, r, 0.2);
        // r = 1.0 - abs(r - 0.5) * 2.0; // si tu veux un V-shape, décommente
        color = vec4(diskColor, r);

    } else if (hitBlackHole) {
        // Trou noir : noir comme ton écran (et ta nuit d’avant rendu)
        color = vec4(0.0, 0.0, 0.0, 1.0);

    } else if (hitObject) {
        // Ombre/light minimaliste : on éclaire en regardant depuis la caméra (cheap et lisible)
        vec3 P = vec3(ray.x, ray.y, ray.z);
        vec3 N = normalize(P - hitCenter);
        vec3 V = normalize(cam.camPos - P);
        float ambient = 0.1;
        float diff = max(dot(N, V), 0.0);
        float intensity = ambient + (1.0 - ambient) * diff;
        vec3 shaded = objectColor.rgb * intensity;
        color = vec4(shaded, objectColor.a);

    } else {
        // Fond transparent/noir — le vide intersidéral, classique
        color = vec4(0.0);
    }

    // Et on peint le pixel, chef !
    imageStore(outImage, pix, color);
}
